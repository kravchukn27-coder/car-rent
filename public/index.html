<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Booking Car Scout</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <div class="page">
    <header class="header">
      <h1 class="header-title">Booking Car Scout</h1>
      <p class="header-desc">Поиск выгодной аренды авто на Booking по выбранным датам</p>
    </header>

    <main class="main">
      <section class="card search-card">
        <div class="mode-tabs">
          <button type="button" id="modeRegularBtn" class="mode-tab active">Поиск</button>
          <button type="button" id="modeFlexBtn" class="mode-tab">У меня гибкие планы</button>
        </div>

        <p class="hint hint-calendar" id="calendarHint">
          Выберите период аренды в календаре (от 1 до 7 дней).
        </p>

        <div class="flex-presets flex-only" id="flexPresetsWrap">
          <span class="flex-presets-label">Быстрый выбор:</span>
          <div class="flex-presets-buttons">
            <button type="button" class="flex-preset-btn" id="presetWeekendsMonth" data-preset="weekends-month">Выходные месяца</button>
            <button type="button" class="flex-preset-btn" id="presetFriWeekends" data-preset="fri-weekends">Пятница + выходные</button>
          </div>
        </div>

        <div class="calendar-wrap">
          <div class="calendar-head">
            <button type="button" class="cal-nav" id="prevMonthBtn" aria-label="Предыдущий месяц">←</button>
            <button type="button" class="cal-nav" id="nextMonthBtn" aria-label="Следующий месяц">→</button>
          </div>
          <div class="calendar-two-months">
            <div class="calendar-month">
              <p class="calendar-month-title" id="monthTitle1"></p>
              <div class="calendar-weekdays">
                <span>ПН</span><span>ВТ</span><span>СР</span><span>ЧТ</span><span>ПТ</span><span>СБ</span><span>ВС</span>
              </div>
              <div class="calendar-grid" id="calendarGrid1"></div>
            </div>
          </div>
          <p class="calendar-selected" id="selectedRangeText">Не выбрано</p>
        </div>

        <div class="form-row form-main">
          <div class="field" id="rentDaysWrap">
            <label for="rentDays">Аренда на сколько дней?</label>
            <input type="number" id="rentDays" min="1" max="7" step="1" value="2" />
          </div>
          <div class="field flex-only" id="flexTimesWrap">
            <label for="flexTimeSelect">Время выдачи</label>
            <div class="flex-time-dropdown" id="flexTimeDropdown">
              <button type="button" class="flex-time-trigger" id="flexTimeTrigger" aria-expanded="false" aria-haspopup="listbox" aria-label="Выберите время выдачи">
                <span class="flex-time-value" id="flexTimeValue">Выберите время</span>
                <span class="flex-time-arrow">▼</span>
              </button>
              <div class="flex-time-list" id="flexTimeList" role="listbox" aria-multiselectable="true" hidden>
                <!-- options filled by JS -->
              </div>
            </div>
          </div>
        </div>

        <div class="actions">
          <button type="button" class="btn btn-primary" id="runBtn">Запустить поиск</button>
          <button type="button" class="btn btn-secondary" id="loadBtn">Показать последний результат</button>
        </div>
        <p class="status status-hidden" id="status" aria-live="polite"></p>

        <div id="progressBlock" class="progress" hidden>
          <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
            <div id="progressFill" class="progress-fill"></div>
          </div>
          <p id="progressMeta" class="progress-meta"></p>
          <p id="progressPhrase" class="progress-phrase"></p>
        </div>
        <div id="captchaNotice" class="captcha-notice" hidden></div>
      </section>

      <div id="analysisBlock" class="card surface-block" hidden></div>
      <div id="resultsBlock" class="card surface-block" hidden>
        <div class="window-tabs" id="windowTabs"></div>
        <div class="sort-row">
          <label for="timeFilter">Время выдачи:</label>
          <select id="timeFilter"><option value="">Все</option></select>
          <label for="sort">Сортировка:</label>
          <select id="sort">
            <option value="price">По цене (сначала дешевле)</option>
            <option value="priceDesc">По цене (сначала дороже)</option>
            <option value="location">По локации (А–Я)</option>
            <option value="date">По времени выдачи</option>
          </select>
        </div>
        <div class="cards" id="cards"></div>
      </div>
      <div id="emptyBlock" class="card empty surface-block">
        Нет данных. Выберите даты и нажмите «Запустить поиск» или загрузите последний результат.
      </div>
    </main>
  </div>

  <div id="captchaModal" class="modal" aria-live="polite" aria-modal="true" role="dialog" hidden>
    <div class="modal-content">
      <h3 class="modal-title">Нужна проверка на Booking</h3>
      <p class="modal-text" id="captchaModalText">Откройте окно с Booking, пройдите капчу и вернитесь — поиск продолжится автоматически.</p>
      <button type="button" class="btn btn-secondary" id="captchaModalAckBtn">Понятно</button>
    </div>
  </div>

  <script>
    (function() {
      const MIN_RENT_DAYS = 1;
      const MAX_RENT_DAYS = 7;
      const MAX_WINDOW_DAYS = 7;
      const FLEX_MAX_DATES = 6;
      const FLEX_MIN_HOUR = 8;
      const FLEX_MAX_HOUR = 18;

      const runBtn = document.getElementById("runBtn");
      const loadBtn = document.getElementById("loadBtn");
      const statusEl = document.getElementById("status");
      const analysisBlock = document.getElementById("analysisBlock");
      const resultsBlock = document.getElementById("resultsBlock");
      const emptyBlock = document.getElementById("emptyBlock");
      const sortEl = document.getElementById("sort");
      const timeFilterEl = document.getElementById("timeFilter");
      const cardsEl = document.getElementById("cards");
      const windowTabsEl = document.getElementById("windowTabs");
      const progressBlock = document.getElementById("progressBlock");
      const progressFill = document.getElementById("progressFill");
      const progressMeta = document.getElementById("progressMeta");
      const progressPhrase = document.getElementById("progressPhrase");
      const captchaNotice = document.getElementById("captchaNotice");
      const captchaModal = document.getElementById("captchaModal");
      const captchaModalText = document.getElementById("captchaModalText");
      const captchaModalAckBtn = document.getElementById("captchaModalAckBtn");
      const modeRegularBtn = document.getElementById("modeRegularBtn");
      const modeFlexBtn = document.getElementById("modeFlexBtn");
      const calendarHint = document.getElementById("calendarHint");
      const monthTitle1 = document.getElementById("monthTitle1");
      const calendarGrid1 = document.getElementById("calendarGrid1");
      const selectedRangeText = document.getElementById("selectedRangeText");
      const prevMonthBtn = document.getElementById("prevMonthBtn");
      const nextMonthBtn = document.getElementById("nextMonthBtn");
      const rentDaysEl = document.getElementById("rentDays");
      const flexTimesWrap = document.getElementById("flexTimesWrap");
      const flexTimeTrigger = document.getElementById("flexTimeTrigger");
      const flexTimeValue = document.getElementById("flexTimeValue");
      const flexTimeList = document.getElementById("flexTimeList");

      let searchMode = "regular";
      let flexPresetDates = null;
      let activePresetId = null;
      let flexSelectedTimes = new Set([10, 16]);
      let rangeStart = null;
      let rangeEnd = null;
      let viewMonth = new Date(new Date().getFullYear(), new Date().getMonth(), 1);
      let progressTimer = null;
      let targetMatchKey = null;
      let resetTimeFilterTimer = null;
      let wasCaptchaActive = false;
      let captchaModalDismissed = false;
      let lastProgressPercent = null;
      let lastProgressPhraseIndex = -1;
      const PROGRESS_PHRASES = [
        "Ищем цены…",
        "Сравниваем варианты…",
        "Обрабатываем результаты…",
      ];

      function toISODate(d) { return d.toISOString().slice(0, 10); }
      function toLocalDateString(d) {
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, "0");
        const day = String(d.getDate()).padStart(2, "0");
        return y + "-" + m + "-" + day;
      }
      function dateFromISO(iso) { return new Date(iso + "T00:00:00"); }
      function addDays(iso, n) {
        const d = dateFromISO(iso);
        d.setDate(d.getDate() + n);
        return toLocalDateString(d);
      }
      function daysBetween(startIso, endIso) {
        const a = dateFromISO(startIso);
        const b = dateFromISO(endIso);
        return Math.round((b - a) / (24 * 60 * 60 * 1000));
      }
      function formatDisplayDate(iso) {
        if (!iso) return "";
        const d = dateFromISO(iso);
        return d.toLocaleDateString("ru-RU", { day: "numeric", month: "short", year: "numeric" });
      }
      function escapeHtml(s) {
        if (s == null) return "";
        const div = document.createElement("div");
        div.textContent = s;
        return div.innerHTML;
      }

      function setStatus(msg, className) {
        statusEl.textContent = msg || "";
        statusEl.className = "status " + (className || "");
      }

      function setMode(mode) {
        searchMode = mode;
        const isFlex = mode === "flex";
        modeRegularBtn.classList.toggle("active", !isFlex);
        modeFlexBtn.classList.toggle("active", isFlex);
        flexTimesWrap.classList.toggle("hidden", !isFlex);
        document.getElementById("flexPresetsWrap").classList.toggle("hidden", !isFlex);
        if (!isFlex) {
          flexPresetDates = null;
          activePresetId = null;
        }
        calendarHint.textContent = isFlex
          ? "Выберите диапазон дат или нажмите пресет: будут проверены выбранные дни (до 6)."
          : "Выберите период аренды в календаре (от 1 до 7 дней).";
        updateSelectedText();
        updatePresetButtonsActive();
        renderCalendar();
      }

      function updateSelectedText() {
        if (searchMode === "flex" && flexPresetDates && flexPresetDates.length > 0) {
          selectedRangeText.textContent = "Выбрано: " + flexPresetDates.length + " дн. (пресет)";
          return;
        }
        if (!rangeStart && !rangeEnd) {
          selectedRangeText.textContent = "Не выбрано";
          return;
        }
        if (rangeStart && !rangeEnd) {
          selectedRangeText.textContent = "Выбрано начало: " + formatDisplayDate(rangeStart) + ". Кликните дату конца.";
          return;
        }
        const span = daysBetween(rangeStart, rangeEnd) + 1;
        if (searchMode === "flex") {
          selectedRangeText.textContent = "Период: " + formatDisplayDate(rangeStart) + " — " + formatDisplayDate(rangeEnd) + " (" + span + " дн.)";
        } else {
          selectedRangeText.textContent = "Период: " + formatDisplayDate(rangeStart) + " — " + formatDisplayDate(rangeEnd);
        }
      }

      function getRentDays() {
        const raw = String(rentDaysEl.value || "").trim();
        const v = parseInt(raw, 10);
        return Number.isFinite(v) ? Math.min(MAX_RENT_DAYS, Math.max(MIN_RENT_DAYS, v)) : MIN_RENT_DAYS;
      }
      function validateRentDaysInput() {
        const raw = String(rentDaysEl.value || "").trim();
        if (!raw) {
          rentDaysEl.setCustomValidity("Введите число от 1 до 7.");
          return false;
        }
        if (!/^\d+$/.test(raw)) {
          rentDaysEl.setCustomValidity("Допустимы только цифры от 1 до 7.");
          return false;
        }
        const num = parseInt(raw, 10);
        if (!Number.isFinite(num) || num < MIN_RENT_DAYS || num > MAX_RENT_DAYS) {
          rentDaysEl.setCustomValidity("Введите значение от 1 до 7.");
          return false;
        }
        rentDaysEl.setCustomValidity("");
        return true;
      }

      function getPresetDatesWeekendsMonth() {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const todayIso = toLocalDateString(today);
        const out = [];
        for (let monthOffset = 0; monthOffset <= 1 && out.length < FLEX_MAX_DATES; monthOffset++) {
          const d = new Date(viewMonth.getFullYear(), viewMonth.getMonth() + monthOffset, 1);
          const y = d.getFullYear();
          const m = d.getMonth();
          const daysInMonth = new Date(y, m + 1, 0).getDate();
          for (let day = 1; day <= daysInMonth && out.length < FLEX_MAX_DATES; day++) {
            const cell = new Date(y, m, day);
            const iso = toLocalDateString(cell);
            if (iso < todayIso) continue;
            const w = cell.getDay();
            if (w === 6 || w === 0) out.push(iso);
          }
        }
        return out;
      }
      function getPresetDatesFriWeekends() {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const todayIso = toLocalDateString(today);
        const out = [];
        for (let monthOffset = 0; monthOffset <= 1 && out.length < FLEX_MAX_DATES; monthOffset++) {
          const d = new Date(viewMonth.getFullYear(), viewMonth.getMonth() + monthOffset, 1);
          const y = d.getFullYear();
          const m = d.getMonth();
          const daysInMonth = new Date(y, m + 1, 0).getDate();
          for (let day = 1; day <= daysInMonth && out.length < FLEX_MAX_DATES; day++) {
            const cell = new Date(y, m, day);
            const iso = toLocalDateString(cell);
            if (iso < todayIso) continue;
            const w = cell.getDay();
            if (w === 5 || w === 6 || w === 0) out.push(iso);
          }
        }
        return out;
      }
      function applyPreset(presetId) {
        if (activePresetId === presetId) {
          flexPresetDates = null;
          activePresetId = null;
          setStatus("");
          updatePresetButtonsActive();
          updateSelectedText();
          renderCalendar();
          return;
        }
        let dates = [];
        if (presetId === "weekends-month") dates = getPresetDatesWeekendsMonth();
        else if (presetId === "fri-weekends") dates = getPresetDatesFriWeekends();
        if (dates.length === 0) {
          setStatus("В выбранном месяце нет подходящих дат для этого пресета.", "error");
          return;
        }
        flexPresetDates = dates.slice(0, FLEX_MAX_DATES);
        activePresetId = presetId;
        rangeStart = null;
        rangeEnd = null;
        setStatus("");
        updatePresetButtonsActive();
        updateSelectedText();
        renderCalendar();
      }
      function updatePresetButtonsActive() {
        document.querySelectorAll(".flex-preset-btn").forEach(function(btn) {
          btn.classList.toggle("active", btn.dataset.preset === activePresetId);
        });
      }
      function getPickupDatesForFlex() {
        if (flexPresetDates && flexPresetDates.length > 0) return flexPresetDates.slice(0, FLEX_MAX_DATES);
        return rangeToPickupDates();
      }

      function fillFlexTimeOptions() {
        let html = "";
        for (let h = FLEX_MIN_HOUR; h <= FLEX_MAX_HOUR; h++) {
          const label = String(h).padStart(2, "0") + ":00";
          const selected = flexSelectedTimes.has(h);
          html += '<div class="flex-time-option' + (selected ? " selected" : "") + '" role="option" aria-selected="' + selected + '" data-value="' + h + '" tabindex="0">' + escapeHtml(label) + '</div>';
        }
        flexTimeList.innerHTML = html;
        flexTimeList.querySelectorAll(".flex-time-option").forEach(function(opt) {
          opt.addEventListener("click", function() {
            const v = parseInt(opt.dataset.value, 10);
            if (flexSelectedTimes.has(v)) {
              flexSelectedTimes.delete(v);
            } else {
              flexSelectedTimes.add(v);
            }
            opt.classList.toggle("selected", flexSelectedTimes.has(v));
            opt.setAttribute("aria-selected", flexSelectedTimes.has(v));
            updateFlexTimeValue();
          });
        });
        updateFlexTimeValue();
      }
      function updateFlexTimeValue() {
        if (flexSelectedTimes.size === 0) {
          flexTimeValue.textContent = "Выберите время";
          flexTimeTrigger.classList.add("placeholder");
          return;
        }
        flexTimeTrigger.classList.remove("placeholder");
        const arr = Array.from(flexSelectedTimes).sort(function(a, b) { return a - b; });
        flexTimeValue.textContent = arr.map(function(h) { return String(h).padStart(2, "0") + ":00"; }).join(", ");
      }

      flexTimeTrigger.addEventListener("click", function(e) {
        e.stopPropagation();
        const isOpen = flexTimeList.hidden === false;
        flexTimeList.hidden = isOpen;
        flexTimeTrigger.setAttribute("aria-expanded", !isOpen);
      });
      document.addEventListener("click", function() {
        flexTimeList.hidden = true;
        flexTimeTrigger.setAttribute("aria-expanded", "false");
      });
      flexTimeList.addEventListener("click", function(e) { e.stopPropagation(); });

      function renderCalendar() {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const todayIso = toLocalDateString(today);

        function buildMonthCells(y, m) {
          const firstDay = new Date(y, m, 1);
          const offset = (firstDay.getDay() + 6) % 7;
          const daysInMonth = new Date(y, m + 1, 0).getDate();
          const presetSet = (searchMode === "flex" && flexPresetDates && flexPresetDates.length > 0) ? new Set(flexPresetDates) : null;
          const hasPendingRegularRange = searchMode === "regular" && rangeStart && !rangeEnd;
          let minEndIso = null;
          let maxEndIso = null;
          if (hasPendingRegularRange) {
            const rentDays = getRentDays();
            minEndIso = addDays(rangeStart, rentDays - 1);
            maxEndIso = addDays(rangeStart, MAX_WINDOW_DAYS - 1);
          }
          const cells = [];
          for (let i = 0; i < offset; i++) cells.push({ empty: true });
          for (let day = 1; day <= daysInMonth; day++) {
            const iso = toLocalDateString(new Date(y, m, day));
            const isPast = iso < todayIso;
            const isToday = iso === todayIso;
            let inRange = false, isStart = false, isEnd = false, allowedEnd = false, blockedEnd = false;
            if (rangeStart && rangeEnd) {
              if (iso === rangeStart) isStart = true;
              else if (iso === rangeEnd) isEnd = true;
              else if (iso > rangeStart && iso < rangeEnd) inRange = true;
            } else if (rangeStart && iso === rangeStart) {
              isStart = true;
            }
            if (hasPendingRegularRange && !isPast && iso > rangeStart) {
              if (iso >= minEndIso && iso <= maxEndIso) {
                allowedEnd = true;
              } else {
                blockedEnd = true;
              }
            }
            const isPresetSelected = presetSet && presetSet.has(iso);
            cells.push({ iso, day, isPast, isToday, isStart, isEnd, inRange, isPresetSelected, allowedEnd, blockedEnd });
          }
          while (cells.length % 7 !== 0) cells.push({ empty: true });
          return cells;
        }

        function cellsToHtml(cells) {
          return cells.map(function(c) {
            if (c.empty) return '<button type="button" class="cal-day empty" disabled></button>';
            const classes = ["cal-day"];
            if (c.isPast) classes.push("past");
            if (c.isToday && !c.isStart && !c.isEnd && !c.inRange && !c.isPresetSelected) classes.push("today");
            if (c.isStart) classes.push("start");
            if (c.isEnd) classes.push("end");
            if (c.inRange) classes.push("range");
            if (c.isPresetSelected) classes.push("preset");
            if (c.allowedEnd && !c.isStart && !c.isEnd && !c.inRange) classes.push("allowed-end");
            if (c.blockedEnd) classes.push("blocked-end");
            const isDisabled = c.isPast || c.blockedEnd;
            return '<button type="button" class="' + classes.join(" ") + '" data-date="' + escapeHtml(c.iso) + '"' + (isDisabled ? " disabled" : "") + '>' + c.day + '</button>';
          }).join("");
        }

        function attachClicks(gridEl) {
          gridEl.querySelectorAll(".cal-day[data-date]").forEach(function(btn) {
            btn.addEventListener("click", function() {
              const iso = btn.dataset.date;
              if (btn.disabled) return;
              if (searchMode === "flex") {
                flexPresetDates = null;
                activePresetId = null;
                updatePresetButtonsActive();
              }
              if (rangeStart && rangeEnd && iso === rangeStart) {
                rangeStart = null;
                rangeEnd = null;
              } else if (!rangeStart || (rangeStart && rangeEnd)) {
                rangeStart = iso;
                rangeEnd = null;
              } else {
                if (iso === rangeStart) {
                  rangeStart = null;
                  rangeEnd = null;
                } else if (iso < rangeStart) {
                  rangeStart = iso;
                  rangeEnd = null;
                } else {
                  const span = daysBetween(rangeStart, iso) + 1;
                  if (searchMode === "regular") {
                    if (span < getRentDays() || span > MAX_WINDOW_DAYS) {
                      setStatus("Период должен быть от " + getRentDays() + " до " + MAX_WINDOW_DAYS + " дней.", "error");
                      return;
                    }
                  } else {
                    if (span > FLEX_MAX_DATES) {
                      setStatus("В гибком периоде можно выбрать не более " + FLEX_MAX_DATES + " дней.", "error");
                      return;
                    }
                  }
                  rangeEnd = iso;
                }
              }
              setStatus("");
              updateSelectedText();
              renderCalendar();
            });
          });
        }

        const y1 = viewMonth.getFullYear();
        const m1 = viewMonth.getMonth();
        const monthLabel1 = viewMonth.toLocaleDateString("ru-RU", { month: "long", year: "numeric" });
        monthTitle1.textContent = monthLabel1;

        const cells1 = buildMonthCells(y1, m1);
        calendarGrid1.innerHTML = cellsToHtml(cells1);
        attachClicks(calendarGrid1);
      }

      prevMonthBtn.addEventListener("click", function() {
        viewMonth = new Date(viewMonth.getFullYear(), viewMonth.getMonth() - 1, 1);
        renderCalendar();
      });
      nextMonthBtn.addEventListener("click", function() {
        viewMonth = new Date(viewMonth.getFullYear(), viewMonth.getMonth() + 1, 1);
        renderCalendar();
      });
      modeRegularBtn.addEventListener("click", function() { setMode("regular"); });
      modeFlexBtn.addEventListener("click", function() { setMode("flex"); });
      rentDaysEl.addEventListener("input", function() {
        // Не перезаписываем значение во время печати, иначе "6" легко превращается в "26" -> clamp до 7.
        // Клэмп и нормализацию делаем на blur/при запуске поиска.
        validateRentDaysInput();
        updateSelectedText();
        renderCalendar();
      });
      rentDaysEl.addEventListener("focus", function() {
        rentDaysEl.select();
      });
      rentDaysEl.addEventListener("blur", function() {
        rentDaysEl.value = String(getRentDays());
        validateRentDaysInput();
      });

      fillFlexTimeOptions();
      setMode("regular");
      renderCalendar();
      document.querySelectorAll(".flex-preset-btn").forEach(function(btn) {
        btn.addEventListener("click", function() { applyPreset(btn.dataset.preset); });
      });

      function getValidatedFlexTimes() {
        const times = Array.from(flexSelectedTimes).filter(function(v) { return Number.isFinite(v) && v >= FLEX_MIN_HOUR && v <= FLEX_MAX_HOUR; }).sort(function(a, b) { return a - b; });
        if (times.length < 1) return { ok: false, message: "Выберите минимум одно время выдачи (08:00–18:00)." };
        return { ok: true, times: times };
      }

      function rangeToPickupDates() {
        if (!rangeStart || !rangeEnd) return [];
        const out = [];
        let d = dateFromISO(rangeStart);
        const end = dateFromISO(rangeEnd);
        while (d <= end && out.length < FLEX_MAX_DATES) {
          out.push(toLocalDateString(d));
          d.setDate(d.getDate() + 1);
        }
        return out;
      }

      function stopProgressPolling() {
        if (progressTimer) { clearInterval(progressTimer); progressTimer = null; }
      }
      function hideProgress() {
        progressBlock.hidden = true;
        progressFill.style.width = "0%";
        progressMeta.textContent = "";
        progressPhrase.textContent = "";
        captchaNotice.hidden = true;
        captchaNotice.textContent = "";
        captchaModal.hidden = true;
        wasCaptchaActive = false;
        captchaModalDismissed = false;
      }
      function showProgress() {
        progressBlock.hidden = false;
        progressFill.style.width = "5%";
        progressMeta.textContent = "Прогресс: 5%";
        progressPhrase.textContent = "";
        lastProgressPercent = null;
        captchaNotice.hidden = true;
        captchaModal.hidden = true;
        wasCaptchaActive = false;
        captchaModalDismissed = false;
      }
      function getRandomPhrase() {
        if (PROGRESS_PHRASES.length === 0) return "";
        let idx = Math.floor(Math.random() * PROGRESS_PHRASES.length);
        if (idx === lastProgressPhraseIndex && PROGRESS_PHRASES.length > 1)
          idx = (idx + 1) % PROGRESS_PHRASES.length;
        lastProgressPhraseIndex = idx;
        return PROGRESS_PHRASES[idx];
      }
      function pollProgress() {
        fetch("/api/progress").then(function(r) { return r.ok ? r.json() : null; }).then(function(p) {
          if (!p) return;
          const percent = Math.min(100, Math.max(0, p.percent || 0));
          const displayPercent = percent === 0 ? 5 : percent;
          progressFill.style.width = displayPercent + "%";
          progressBlock.querySelector("[role=progressbar]").setAttribute("aria-valuenow", percent);
          const eta = p.etaSec && p.etaSec > 0 ? Math.ceil(p.etaSec / 60) : null;
          progressMeta.textContent = eta ? "Прогресс: " + displayPercent + "%, осталось ~" + eta + " мин" : "Прогресс: " + displayPercent + "%";
          if (lastProgressPercent !== percent) {
            progressPhrase.textContent = getRandomPhrase();
            lastProgressPercent = percent;
          }
          if (p.captchaRequired) {
            captchaNotice.hidden = false;
            captchaNotice.textContent = "Нужна проверка на Booking: откройте окно браузера, пройдите капчу — поиск продолжится.";
            captchaModalText.textContent = "Откройте окно с Booking, пройдите капчу и вернитесь сюда.";
            if (!captchaModalDismissed) captchaModal.hidden = false;
            setStatus("Требуется капча.", "error");
            wasCaptchaActive = true;
          } else {
            captchaNotice.hidden = true;
            captchaModal.hidden = true;
            captchaModalDismissed = false;
            if (wasCaptchaActive) { setStatus("Капча пройдена, продолжаем…", "loading"); wasCaptchaActive = false; }
          }
        }).catch(function() {});
      }
      captchaModalAckBtn.addEventListener("click", function() {
        captchaModalDismissed = true;
        captchaModal.hidden = true;
      });

      function getWindowKey(m) { return m.pickup + "|" + m.dropoff; }
      function formatDateNoYear(iso) {
        if (!iso) return "";
        const parts = iso.split("-");
        return (parts[2] || "") + "." + (parts[1] || "");
      }
      function buildWindows(matches) {
        const byKey = new Map();
        matches.forEach(function(m) {
          const key = getWindowKey(m);
          if (!byKey.has(key)) byKey.set(key, { key, pickup: m.pickup, dropoff: m.dropoff, matches: [] });
          byKey.get(key).matches.push(m);
        });
        const list = Array.from(byKey.values()).map(function(w) {
          const days = daysBetween(w.pickup, w.dropoff);
          const minPrice = w.matches.reduce(function(min, m) {
            const v = Number(m.priceValue);
            return Number.isFinite(v) ? Math.min(min, v) : min;
          }, Infinity);
          return {
            key: w.key,
            pickup: w.pickup,
            dropoff: w.dropoff,
            days: days,
            label: formatDateNoYear(w.pickup) + " – " + formatDateNoYear(w.dropoff) + " (" + days + " дн.)",
            count: w.matches.length,
            minPrice: minPrice,
            matches: w.matches,
            searchUrl: (w.matches[0] && w.matches[0].searchUrl) ? w.matches[0].searchUrl : null
          };
        });
        // Сначала более короткие аренды, затем по дате начала.
        list.sort(function(a, b) {
          if (a.days !== b.days) return a.days - b.days;
          return a.pickup.localeCompare(b.pickup);
        });
        return list;
      }
      function sortMatches(matches, sortBy) {
        const arr = matches.slice();
        if (sortBy === "price") arr.sort(function(a, b) { return a.priceValue - b.priceValue; });
        else if (sortBy === "priceDesc") arr.sort(function(a, b) { return b.priceValue - a.priceValue; });
        else if (sortBy === "location") arr.sort(function(a, b) { return (a.location || "").localeCompare(b.location || ""); });
        else if (sortBy === "date") arr.sort(function(a, b) { return (a.pickup + " " + (a.time || a.pickupTime || "")).localeCompare(b.pickup + " " + (b.time || b.pickupTime || "")); });
        return arr;
      }
      function getMatchHourValue(m) {
        const raw = m && (m.time != null ? m.time : m.pickupTime);
        if (raw == null) return null;
        const parsed = parseInt(String(raw).replace(":00", ""), 10);
        return Number.isFinite(parsed) ? String(parsed) : null;
      }
      function setTimeFilterOptions(matches, preferred) {
        const values = Array.from(new Set((matches || []).map(getMatchHourValue).filter(Boolean))).sort(function(a, b) { return Number(a) - Number(b); });
        const current = preferred || timeFilterEl.value;
        timeFilterEl.innerHTML = '<option value="">Все</option>' + values.map(function(v) { return '<option value="' + escapeHtml(v) + '">' + escapeHtml(v) + ':00</option>'; }).join("");
        timeFilterEl.value = (current && values.indexOf(current) >= 0) ? current : "";
      }
      function renderWindowTabs(windows, selectedKey) {
        const groups = new Map();
        windows.forEach(function(w) {
          const key = String(w.days);
          if (!groups.has(key)) groups.set(key, []);
          groups.get(key).push(w);
        });
        const sortedDayKeys = Array.from(groups.keys()).sort(function(a, b) { return Number(a) - Number(b); });
        let html = "";
        sortedDayKeys.forEach(function(dayKey) {
          const dayWindows = groups.get(dayKey) || [];
          html += '<div class="window-group">';
          html += '<div class="window-group-label">' + escapeHtml(dayKey + " дн.") + '</div>';
          dayWindows.forEach(function(w) {
            html += '<button type="button" class="window-tab' + (w.key === selectedKey ? " active" : "") + '" data-window="' + escapeHtml(w.key) + '">' +
              escapeHtml(w.label) + (Number.isFinite(w.minPrice) ? " €" + w.minPrice : "") + ' <span class="count">(' + w.count + ')</span></button>';
          });
          html += '</div>';
        });
        windowTabsEl.innerHTML = html;
        windowTabsEl.querySelectorAll(".window-tab").forEach(function(btn) {
          btn.addEventListener("click", function() {
            window.selectedWindowKey = btn.dataset.window;
            renderWindowTabs(windows, window.selectedWindowKey);
            applyFiltersAndRender();
          });
        });
      }
      function applyFiltersAndRender() {
        const win = window.windows && window.selectedWindowKey ? window.windows.find(function(w) { return w.key === window.selectedWindowKey; }) : null;
        if (!win) { renderCards([], null); return; }
        const timeVal = timeFilterEl.value;
        const getTime = function(m) { return String(m.time != null ? m.time : m.pickupTime || "").replace(":00", ""); };
        const filtered = timeVal ? win.matches.filter(function(m) { return getTime(m) === timeVal; }) : win.matches;
        renderCards(filtered, win.searchUrl);
      }
      function renderCards(matches, windowSearchUrl) {
        const sortBy = sortEl.value;
        const sorted = sortMatches(matches, sortBy);
        let html = "";
        if (windowSearchUrl) html += '<p class="search-link-row"><a href="' + escapeHtml(windowSearchUrl) + '" target="_blank" rel="noopener" class="card-link">Открыть поиск на Booking для этого окна</a></p>';
        sorted.forEach(function(m) {
          const cardKey = [m.pickup, m.dropoff, m.time, m.supplier, m.location, m.model, m.priceValue].join("|");
          var days = null;
          if (m.pickup && m.dropoff) {
            var diff = daysBetween(m.pickup, m.dropoff);
            if (Number.isFinite(diff)) days = diff;
          }
          var perDay = null;
          if (days != null && days >= 1 && Number.isFinite(m.priceValue)) {
            perDay = Math.round(m.priceValue / days);
          }
          var priceHtml = escapeHtml(m.priceText);
          if (perDay != null) {
            priceHtml += ' (' + escapeHtml('€ ' + perDay + '/сутки') + ')';
          }
          html += '<div class="result-card' + (targetMatchKey === cardKey ? " target" : "") + '" data-match-key="' + escapeHtml(cardKey) + '">' +
            '<div class="result-price">' + priceHtml + '</div>' +
            '<div class="result-body">' +
              '<div class="result-title">' + escapeHtml(m.model) + '</div>' +
              '<div class="result-meta">' + escapeHtml(m.supplier) + ' · ' + escapeHtml(m.location) + ' · ' + m.pickup + " – " + m.dropoff + ", " + (m.time || m.pickupTime || "") + '</div>' +
            '</div>' +
            '<span class="result-badge">' + escapeHtml(m.location) + '</span></div>';
        });
        cardsEl.innerHTML = html;
        if (targetMatchKey) {
          var t = cardsEl.querySelector('.result-card[data-match-key="' + CSS.escape(targetMatchKey) + '"]');
          if (t) { t.scrollIntoView({ behavior: "smooth", block: "center" }); setTimeout(function() { t.classList.remove("target"); }, 3000); }
          targetMatchKey = null;
        }
      }
      sortEl.addEventListener("change", applyFiltersAndRender);
      timeFilterEl.addEventListener("change", applyFiltersAndRender);

      function showResults(data) {
        const matches = data.matches || [];
        if (matches.length === 0) {
          resultsBlock.hidden = true;
          analysisBlock.hidden = true;
          emptyBlock.hidden = false;
          emptyBlock.textContent = "Нет результатов.";
          return;
        }
        emptyBlock.hidden = true;
        resultsBlock.hidden = false;
        const analysis = data.analysis;
        if (analysis && analysis.globalMin) {
          analysisBlock.hidden = false;

          const gm = analysis.globalMin;
          const gmTimeStr = gm.time != null ? String(gm.time).padStart(2, "0") + ":00" : "";
          const gmDays = daysBetween(gm.pickup, gm.dropoff);
          const gmDateRange = formatDisplayDate(gm.pickup) + " – " + formatDisplayDate(gm.dropoff);

          // Находим самое выгодное по цене за сутки.
          let bestPerDay = null;
          let bestPerDayValue = Infinity;
          (matches || []).forEach(function(m) {
            if (!m.pickup || !m.dropoff) return;
            const diff = daysBetween(m.pickup, m.dropoff);
            if (!Number.isFinite(diff) || diff < 1) return;
            const price = Number(m.priceValue);
            if (!Number.isFinite(price)) return;
            const perDay = price / diff;
            if (perDay < bestPerDayValue) {
              bestPerDayValue = perDay;
              bestPerDay = m;
            }
          });

          let html = '';
          html += '<div class="analysis-header">' +
            '<h3 class="analysis-title">Результаты</h3>' +
            '<span class="analysis-rent-days">Срок аренды: ' + gmDays + ' дн.</span>' +
            '</div>';

          // Карточка 1 — минимальная общая цена.
          html += '<button type="button" class="analysis-card" id="jumpToCheapestBtn">' +
            '<div class="analysis-card-label">Минимальная общая цена</div>' +
            '<div class="analysis-card-price">' + escapeHtml(gm.priceText) + '</div>' +
            '<div class="analysis-card-details">' +
              '<span class="analysis-detail"><span class="analysis-detail-label">Даты</span> ' + escapeHtml(gmDateRange) + '</span>' +
              (gmTimeStr ? '<span class="analysis-detail"><span class="analysis-detail-label">Время</span> ' + escapeHtml(gmTimeStr) + '</span>' : '') +
              '<span class="analysis-detail"><span class="analysis-detail-label">Локация</span> ' + escapeHtml(gm.location) + '</span>' +
              '<span class="analysis-detail"><span class="analysis-detail-label">Прокатчик</span> ' + escapeHtml(gm.supplier) + '</span>' +
            '</div>' +
            '<span class="analysis-card-hint">Показать самое дешёвое предложение</span>' +
          '</button>';

          // Карточка 2 — минимальная цена за сутки (если удалось посчитать).
          if (bestPerDay && Number.isFinite(bestPerDayValue)) {
            const b = bestPerDay;
            const bTimeStr = b.time != null ? String(b.time).padStart(2, "0") + ":00" : "";
            const bDays = daysBetween(b.pickup, b.dropoff);
            const bDateRange = formatDisplayDate(b.pickup) + " – " + formatDisplayDate(b.dropoff);
            const perDayRounded = Math.round(bestPerDayValue);
            html += '<button type="button" class="analysis-card" id="jumpToBestPerDayBtn">' +
              '<div class="analysis-card-label">Минимальная цена за сутки</div>' +
              '<div class="analysis-card-price">€ ' + escapeHtml(String(perDayRounded)) + '/сутки</div>' +
              '<div class="analysis-card-details">' +
                '<span class="analysis-detail"><span class="analysis-detail-label">Общая цена</span> ' + escapeHtml(b.priceText) + '</span>' +
                '<span class="analysis-detail"><span class="analysis-detail-label">Даты</span> ' + escapeHtml(bDateRange) + ' (' + bDays + ' дн.)</span>' +
                (bTimeStr ? '<span class="analysis-detail"><span class="analysis-detail-label">Время</span> ' + escapeHtml(bTimeStr) + '</span>' : '') +
                '<span class="analysis-detail"><span class="analysis-detail-label">Локация</span> ' + escapeHtml(b.location) + '</span>' +
                '<span class="analysis-detail"><span class="analysis-detail-label">Прокатчик</span> ' + escapeHtml(b.supplier) + '</span>' +
              '</div>' +
              '<span class="analysis-card-hint">Показать лучшее по цене за сутки</span>' +
            '</button>';
          }

          analysisBlock.innerHTML = html;

          var jumpBtn = document.getElementById("jumpToCheapestBtn");
          if (jumpBtn) jumpBtn.addEventListener("click", function() {
            var targetWindowKey = gm.pickup + "|" + gm.dropoff;
            var targetTime = gm.time != null ? String(gm.time) : "";
            targetMatchKey = [gm.pickup, gm.dropoff, gm.time, gm.supplier, gm.location, gm.model, gm.priceValue].join("|");
            if (window.windows && window.windows.some(function(w) { return w.key === targetWindowKey; })) window.selectedWindowKey = targetWindowKey;
            if (targetTime) timeFilterEl.value = targetTime;
            renderWindowTabs(window.windows, window.selectedWindowKey);
            applyFiltersAndRender();
            if (resetTimeFilterTimer) clearTimeout(resetTimeFilterTimer);
            resetTimeFilterTimer = setTimeout(function() { timeFilterEl.value = ""; applyFiltersAndRender(); }, 3000);
          });

          var jumpBestBtn = document.getElementById("jumpToBestPerDayBtn");
          if (jumpBestBtn && bestPerDay) jumpBestBtn.addEventListener("click", function() {
            var b = bestPerDay;
            var targetWindowKey = b.pickup + "|" + b.dropoff;
            var targetTime = b.time != null ? String(b.time) : "";
            targetMatchKey = [b.pickup, b.dropoff, b.time, b.supplier, b.location, b.model, b.priceValue].join("|");
            if (window.windows && window.windows.some(function(w) { return w.key === targetWindowKey; })) window.selectedWindowKey = targetWindowKey;
            if (targetTime) timeFilterEl.value = targetTime;
            renderWindowTabs(window.windows, window.selectedWindowKey);
            applyFiltersAndRender();
            if (resetTimeFilterTimer) clearTimeout(resetTimeFilterTimer);
            resetTimeFilterTimer = setTimeout(function() { timeFilterEl.value = ""; applyFiltersAndRender(); }, 3000);
          });
        } else analysisBlock.hidden = true;
        const windows = buildWindows(matches);
        setTimeFilterOptions(matches, timeFilterEl.value);
        window.windows = windows;
        window.selectedWindowKey = (windows[0] && windows[0].key) || null;
        renderWindowTabs(windows, window.selectedWindowKey);
        var cur = windows.find(function(w) { return w.key === window.selectedWindowKey; });
        if (cur) applyFiltersAndRender(); else renderCards([], null);
      }

      loadBtn.addEventListener("click", function() {
        setStatus("Загрузка…", "loading");
        fetch("/api/results").then(function(r) {
          if (!r.ok) throw new Error(r.status === 404 ? "Сначала запустите поиск." : "Ошибка загрузки.");
          return r.json();
        }).then(function(data) {
          window.lastResults = data;
          showResults(data);
          setStatus("Последний результат загружен.");
        }).catch(function(e) { setStatus(e.message, "error"); });
      });

      runBtn.addEventListener("click", function() {
        if (!validateRentDaysInput()) {
          setStatus(rentDaysEl.validationMessage || ("Введите значение от " + MIN_RENT_DAYS + " до " + MAX_RENT_DAYS + "."), "error");
          rentDaysEl.focus();
          rentDaysEl.select();
          return;
        }
        const rentDays = getRentDays();
        if (rentDays < MIN_RENT_DAYS || rentDays > MAX_RENT_DAYS) {
          setStatus("Длительность аренды: от " + MIN_RENT_DAYS + " до " + MAX_RENT_DAYS + " дней.", "error");
          return;
        }
        const isFlex = searchMode === "flex";
        let startDate = null, endDate = null, pickupDates = null;

        if (isFlex) {
          pickupDates = getPickupDatesForFlex();
          if (pickupDates.length === 0) {
            setStatus("Выберите диапазон дат в календаре.", "error");
            return;
          }
          if (pickupDates.length > FLEX_MAX_DATES) {
            setStatus("В гибком периоде максимум " + FLEX_MAX_DATES + " дней.", "error");
            return;
          }
          var flexCheck = getValidatedFlexTimes();
          if (!flexCheck.ok) { setStatus(flexCheck.message, "error"); return; }
        } else {
          if (!rangeStart || !rangeEnd) {
            setStatus("Выберите диапазон дат в календаре.", "error");
            return;
          }
          startDate = rangeStart;
          endDate = rangeEnd;
          var span = daysBetween(startDate, endDate) + 1;
          if (span < rentDays || span > MAX_WINDOW_DAYS) {
            setStatus("Период в календаре: от " + rentDays + " до " + MAX_WINDOW_DAYS + " дней.", "error");
            return;
          }
        }

        runBtn.disabled = true;
        showProgress();
        setStatus("");
        stopProgressPolling();
        progressTimer = setInterval(pollProgress, 1500);

        var body = isFlex
          ? { rentDays: rentDays, pickupDates: pickupDates, pickupTimes: getValidatedFlexTimes().times }
          : { startDate: startDate, endDate: endDate, rentDays: rentDays };

        fetch("/api/run", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body) })
          .then(function(r) { return r.json().then(function(data) { return { ok: r.ok, data: data }; }); })
          .then(function(result) {
            if (!result.ok) {
              var detail = (result.data.stderr || "").slice(0, 400).trim();
              throw new Error(detail ? (result.data.error || "Ошибка") + " — " + detail : (result.data.error || "Ошибка"));
            }
          })
          .then(function() { return pollProgress(); })
          .then(function() {
            stopProgressPolling();
            hideProgress();
            setStatus("Загрузка результатов…", "loading");
            return fetch("/api/results");
          })
          .then(function(r) {
            if (!r.ok) throw new Error("Не удалось загрузить результаты");
            return r.json();
          })
          .then(function(results) {
            window.lastResults = results;
            showResults(results);
            setStatus("");
          })
          .catch(function(e) {
            stopProgressPolling();
            hideProgress();
            setStatus(e.message, "error");
          })
          .finally(function() {
            stopProgressPolling();
            runBtn.disabled = false;
          });
      });
    })();
  </script>
</body>
</html>
