# План развития поиска и UI

## Цели этапов
- Этап 1 (приоритет):
  - всплывающее уведомление в UI при необходимости пройти капчу вручную
  - запуск поиска в скрытом режиме (без видимого окна), с автоматическим переключением на видимый режим только для капчи
- Этап 2:
  - календарная визуализация самых дешёвых дат
- Этап 3:
  - отдельный гибкий поиск v1 на основе списка конкретных дат

## Текущее основание (что переиспользуем)
- UI и клиентская логика: `public/index.html`
- API и управление процессом поиска: `server.js`
- Playwright-раннер и детекция блокировок/капчи: `set_location.js`
- Контракт спецификации и версии: `SPECIFICATION.md`

## Этап 1 — Капча-уведомление + скрытый режим

### 1.1 Событийная модель статусов раннера
- Ввести унифицированные runtime-события в stdout раннера (`set_location.js`), например:
  - `EVENT_CAPTCHA_REQUIRED`
  - `EVENT_CAPTCHA_RESOLVED`
  - `EVENT_MODE_SWITCH headless->headed`
- Парсить эти события в `server.js` рядом с текущим прогрессом `PROGRESS_JOB_DONE`.
- Расширить `GET /api/progress` полями состояния UI:
  - `captchaRequired: boolean`
  - `captchaSince: timestamp|null`
  - `runMode: "headless"|"headed"`
  - `lastEvent: string|null`

Алгоритм:
1. Раннер обнаруживает капчу (уже есть логика `ensureNotBlocked`).
2. Пишет `EVENT_CAPTCHA_REQUIRED`.
3. Сервер сохраняет флаг в `scoutProgress`.
4. UI polling видит флаг и показывает модальное/toast-уведомление.
5. После прохождения капчи раннер пишет `EVENT_CAPTCHA_RESOLVED`, UI скрывает уведомление.

### 1.2 Скрытый запуск с безопасным fallback
- Добавить режим запуска браузера в `set_location.js` через env, например `RUN_HEADLESS=1`.
- Старт по умолчанию в `headless: true`.
- При капче — перевод в видимый режим (новый контекст/браузер в headed) и продолжение очереди job.

Алгоритм переключения:
1. Запустить в headless и выполнять jobs.
2. Если капча подтверждена:
   - зафиксировать текущий job и emit `EVENT_CAPTCHA_REQUIRED`
   - закрыть headless-контекст
   - открыть headed-контекст с тем же профилем
   - повторить текущий job
3. После `EVENT_CAPTCHA_RESOLVED` продолжить оставшиеся jobs.

Риски и меры:
- Риск потери состояния при переключении контекста -> повтор текущего job после switch.
- Риск "залипания" в капче -> таймаут + явный статус ошибки в API.

## Этап 2 — Схематичный календарь дешёвых дат

### 2.1 Модель агрегации
- На сервере или в UI агрегировать `results.json.matches` по дате выдачи (`pickup`).
- Для каждой даты вычислять:
  - `minPrice`
  - `offersCount`
  - `bestOfferRef` (ссылка на конкретную карточку/окно)

Алгоритм:
1. Пройти все `matches`.
2. Группировать по `pickup`.
3. Хранить минимум цены и ссылку на оффер.
4. Отдать структуру в UI для календаря.

### 2.2 Визуализация
- Добавить в `public/index.html` компактную month-grid схему:
  - дни месяца
  - цветовая интенсивность по цене (дешевле = ярче/зелёнее)
  - tooltip: минимальная цена и число предложений
  - клик по дате фильтрует текущий список до соответствующего окна/дня

## Этап 3 — Гибкий поиск v1 (список конкретных дат)

### 3.1 UI-режим "Гибкий поиск"
- Добавить переключатель режима:
  - `Обычный` (текущий диапазон)
  - `Гибкий` (список дат)
- В гибком режиме пользователь отмечает набор дат в календаре.
- Для каждой выбранной даты строится job (`pickupDate`) с текущей `rentDays` и `TIMES`.

### 3.2 API-контракт
- Расширить `POST /api/run`:
  - либо текущие `startDate/endDate`
  - либо `pickupDates: string[]`
- Валидация:
  - массив непустой
  - формат `YYYY-MM-DD`
  - дедупликация и сортировка
  - ограничение верхнего числа job (чтобы не перегружать раннер)

Алгоритм раннера:
1. Если передан `pickupDates[]`, строить jobs только из них.
2. Для каждой даты считать `dropoffDate = pickupDate + rentDays`.
3. Добавлять по всем `TIMES`.
4. Дальше использовать текущий pipeline пула без изменения основной логики парсинга.

## Порядок внедрения (итерации)
1. События капчи + расширение `/api/progress` + UI-уведомление.
2. Headless-by-default + переключение в headed при капче.
3. Календарная агрегация + UI month-grid + переход к офферу по клику.
4. Гибкий режим: UI выбора дат + API `pickupDates[]` + генерация jobs.
5. Документация/версионирование в спецификации и smoke-check сценарии.

## Критерии готовности
- Капча:
  - UI показывает явное уведомление и снимает его после прохождения
  - режим поиска корректно виден в прогрессе (`headless/headed`)
- Headless:
  - поиск идёт без видимого окна до капчи
  - при капче окно появляется и прогон продолжается
- Календарь:
  - отображается минимум цена на каждую дату
  - клик по дате приводит к релевантным карточкам
- Гибкий поиск:
  - принимает и обрабатывает список дат
  - корректно пишет результаты в `results.json`/`results.csv`

## Тест-план (минимум)
- Happy path без капчи в headless.
- Path с капчей: событие, popup, ручное подтверждение, продолжение.
- Календарь на диапазоне с разными ценами и пустыми днями.
- Гибкий поиск на 3-5 разрозненных датах (в т.ч. выходные).
- Ограничения: слишком большой список дат, невалидная дата, дубликаты.
