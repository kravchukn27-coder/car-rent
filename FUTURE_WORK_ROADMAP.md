# План развития поиска и UI

## Цели этапов
- Этап 0 (высокий приоритет) — `planned`:
  - запуск UI как фонового сервиса macOS через `LaunchAgent` (без открытого терминала)
  - открытие поиска напрямую по сохранённой ссылке в Chrome в любой момент
- Этап 1 (приоритет) — `done`:
  - всплывающее уведомление в UI при необходимости пройти капчу вручную
  - запуск поиска в скрытом режиме (без видимого окна), с автоматическим переключением на видимый режим только для капчи
- Этап 3 — `done`:
  - отдельный гибкий поиск v1 на основе списка конкретных дат

## Текущее основание (что переиспользуем)
- UI и клиентская логика: `public/index.html`
- API и управление процессом поиска: `server.js`
- Playwright-раннер и детекция блокировок/капчи: `set_location.js`
- Контракт спецификации и версии: `SPECIFICATION.md`

## Этап 0 — Фоновый запуск UI через LaunchAgent (`planned`, высокий приоритет)

### 0.1 Поведение сервиса
- Настроить `LaunchAgent` для запуска `node server.js` при входе в систему.
- Обеспечить работу без открытого терминала (терминал можно полностью закрыть).
- Закрепить стабильный URL доступа (по умолчанию `http://127.0.0.1:3000`).

### 0.2 Операционный контур
- Добавить команды/скрипты для:
  - установки агента,
  - перезапуска,
  - остановки,
  - просмотра статуса и логов.
- Логи сервиса писать в отдельные файлы для диагностики без терминала.

### 0.3 UX-результат
- Пользователь в любой момент открывает Chrome по сохранённой ссылке и сразу запускает поиск.
- Ручной запуск `npm run ui` в терминале не требуется.

### 0.4 Критерии готовности этапа
- После перезапуска macOS UI доступен автоматически.
- При закрытом терминале `POST /api/run` и `GET /api/results` работают штатно.
- В случае падения сервиса есть понятный путь восстановления (перезапуск LaunchAgent + чтение логов).

## Этап 1 — Капча-уведомление + скрытый режим (`done`)

### 1.1 Событийная модель статусов раннера (`done`)
- Ввести унифицированные runtime-события в stdout раннера (`set_location.js`), например:
  - `EVENT_CAPTCHA_REQUIRED`
  - `EVENT_CAPTCHA_RESOLVED`
  - `EVENT_MODE_SWITCH headless->headed`
- Парсить эти события в `server.js` рядом с текущим прогрессом `PROGRESS_JOB_DONE`.
- Расширить `GET /api/progress` полями состояния UI:
  - `captchaRequired: boolean`
  - `captchaSince: timestamp|null`
  - `runMode: "headless"|"headed"`
  - `lastEvent: string|null`

Алгоритм:
1. Раннер обнаруживает капчу (уже есть логика `ensureNotBlocked`).
2. Пишет `EVENT_CAPTCHA_REQUIRED`.
3. Сервер сохраняет флаг в `scoutProgress`.
4. UI polling видит флаг и показывает модальное/toast-уведомление.
5. После прохождения капчи раннер пишет `EVENT_CAPTCHA_RESOLVED`, UI скрывает уведомление.

### 1.2 Скрытый запуск с безопасным fallback (`cancelled`)
- Добавить режим запуска браузера в `set_location.js` через env, например `RUN_HEADLESS=1`.
- Старт по умолчанию в `headless: true`.
- При капче — перевод в видимый режим (новый контекст/браузер в headed) и продолжение очереди job.

Примечание: пункт отменён для текущей ветки развития, так как в реальных прогонах подход оказался нестабильным (зависания, потеря состояния и регрессии по надёжности).

Алгоритм переключения:
1. Запустить в headless и выполнять jobs.
2. Если капча подтверждена:
   - зафиксировать текущий job и emit `EVENT_CAPTCHA_REQUIRED`
   - закрыть headless-контекст
   - открыть headed-контекст с тем же профилем
   - повторить текущий job
3. После `EVENT_CAPTCHA_RESOLVED` продолжить оставшиеся jobs.

Риски и меры:
- Риск потери состояния при переключении контекста -> повтор текущего job после switch.
- Риск "залипания" в капче -> таймаут + явный статус ошибки в API.

## Этап 3 — Гибкий поиск v1 (список конкретных дат) (`done`)

### 3.1 UI-режим "Гибкий поиск" (`done`)
- Добавить переключатель режима:
  - `Обычный` (текущий диапазон)
  - `Гибкий` (список дат)
- В гибком режиме пользователь отмечает набор дат в календаре.
- Для каждой выбранной даты строится job (`pickupDate`) с текущей `rentDays` и `TIMES`.

### 3.2 API-контракт (`done`)
- Расширить `POST /api/run`:
  - либо текущие `startDate/endDate`
  - либо `pickupDates: string[]`
- Валидация:
  - массив непустой
  - формат `YYYY-MM-DD`
  - дедупликация и сортировка
  - ограничение верхнего числа job (чтобы не перегружать раннер)

Алгоритм раннера:
1. Если передан `pickupDates[]`, строить jobs только из них.
2. Для каждой даты считать `dropoffDate = pickupDate + rentDays`.
3. Добавлять по всем `TIMES`.
4. Дальше использовать текущий pipeline пула без изменения основной логики парсинга.

## Этап 4 — История поиска и сравнение с текущим (`planned`)

### 4.1 UX-концепт
- Добавить отдельную кнопку `История поиска` в `public/index.html` рядом с текущими действиями.
- По клику открывать панель/модальное окно со списком завершённых поисков за текущую сессию UI.
- Каждая запись истории должна показывать минимум:
  - период поиска (`startDate`–`endDate` или набор `pickupDates`)
  - `rentDays`
  - время запуска
  - краткую сводку (`число найденных вариантов`, `минимальная общая цена`, `минимальная цена за сутки`)
- В списке должен быть action `Сравнить с текущим`, чтобы быстро увидеть различия между выбранным историческим поиском и текущей выдачей.

### 4.2 Модель данных (сессия)
- Ввести in-memory хранилище истории на сервере (`server.js`) для текущего процесса:
  - `searchHistory: Array<SearchSnapshot>`
  - ограничение, например, последние `20` записей.
- `SearchSnapshot`:
  - `id`
  - `createdAt`
  - `query` (параметры запроса)
  - `summary` (минимумы/счётчики)
  - `results` (нормализованный срез данных, достаточный для сравнения)
- История живёт до перезапуска UI-сервера (требование "за текущую сессию").

### 4.3 API-контракт
- Добавить новые эндпоинты:
  - `GET /api/history` — список поисков текущей сессии (без тяжёлых полей).
  - `GET /api/history/:id` — полная запись конкретного поиска.
  - `GET /api/history/:id/compare-current` — агрегированное сравнение с текущим `results.json`.
- Сохранять snapshot после каждого успешного `POST /api/run`.

### 4.4 Сравнение (v1)
- В `compare-current` вычислять:
  - разницу по минимальной общой цене;
  - разницу по минимальной цене за сутки;
  - пересечение/различие по окнам (`pickup|dropoff|time`);
  - изменение числа офферов по локациям.
- В UI показывать компактную таблицу/карточки "было vs стало".

### 4.5 Риски и ограничения
- In-memory история будет теряться после рестарта сервера (для v1 это ожидаемо).
- Нужно ограничить размер snapshots, чтобы не раздувать память.
- Сравнение должно работать быстро даже при больших выдачах (использовать предагрегацию ключей).

## Этап 5 — Стабилизация парсинга по локали (бывш. v1.4.1) (`planned`)

- стабилизировать парсинг выдачи Booking независимо от локали интерфейса (английский/испанский и другие), чтобы результаты не зависели от ручного переключения языка в браузере
- зафиксировать язык раннера на уровне запроса и контекста, добавить явную валидацию фактической локали страницы перед парсингом
- убрать хрупкие языковые селекторы (`text`/`alt`), перейти на устойчивые DOM-ориентиры и fallback-пути для поставщика, цены и локации
- добавить диагностический режим для кейса `0 matches` (сводка причин + sample карточек), чтобы быстро локализовать регрессии без ручного дебага

## Порядок внедрения (итерации)
1. Фоновый запуск UI через LaunchAgent (без терминала) — первый приоритет.
2. События капчи + расширение `/api/progress` + UI-уведомление.
3. Headless-by-default + переключение в headed при капче.
4. Календарная агрегация + UI month-grid + переход к офферу по клику.
5. Гибкий режим: UI выбора дат + API `pickupDates[]` + генерация jobs.
6. История поиска: кнопка, список, API текущей сессии, сравнение с текущим результатом.
7. Стабилизация парсинга по локали (независимость от языка страницы и устойчивые селекторы).
8. Документация/версионирование в спецификации и smoke-check сценарии.

## Критерии готовности
- Фоновый запуск (LaunchAgent):
  - UI доступен без открытия терминала
  - сервис автоматически поднимается после логина в macOS
  - есть команды/инструкция для перезапуска и диагностики
- Капча:
  - UI показывает явное уведомление и снимает его после прохождения
  - режим поиска корректно виден в прогрессе (`headless/headed`)
- Headless:
  - поиск идёт без видимого окна до капчи
  - при капче окно появляется и прогон продолжается
- Календарь:
  - отображается минимум цена на каждую дату
  - клик по дате приводит к релевантным карточкам
- Гибкий поиск:
  - принимает и обрабатывает список дат
  - корректно пишет результаты в `results.json`/`results.csv`
- История поиска:
  - после каждого успешного запуска запись появляется в `История поиска`
  - можно открыть прошлый поиск и сравнить его с текущим
  - сравнение показывает различия по минимумам и составу окон
- Стабилизация локали:
  - результаты не зависят от ручного переключения языка в интерфейсе Booking
  - парсер одинаково корректно работает минимум на англоязычной и испаноязычной выдаче

## Тест-план (минимум)
- LaunchAgent: холодный запуск после reboot/login, проверка доступности `http://127.0.0.1:3000` без ручного запуска `npm run ui`.
- Happy path без капчи в headless.
- Path с капчей: событие, popup, ручное подтверждение, продолжение.
- Календарь на диапазоне с разными ценами и пустыми днями.
- Гибкий поиск на 3-5 разрозненных датах (в т.ч. выходные).
- Ограничения: слишком большой список дат, невалидная дата, дубликаты.
- История поиска: минимум 2 последовательных поиска (например `22-28` и `12-20`) и успешное сравнение прошлого поиска с текущим.
- Локаль: одинаковый сценарий поиска в двух языках интерфейса Booking даёт сопоставимые по структуре результаты без ручного вмешательства.
